Orbit Career: AI Resume Analyzer

Live Frontend (Vercel): https://ai-resume-analyzer-frontend.vercel.app
Live Backend (Render): https://ai-resume-analyzer-backend-c3zk.onrender.com

Challenge Submission

This project is a submission for the Orbit AI - Product Enhancement Challenge (October 2025).

Product Choice & Rationale

Product Chosen: 4. Resume Editor

Rationale:
The original "Resume Editor" concept helps students craft a powerful resume. However, the value of a good resume is in its ability to get a job. I saw an opportunity to "elevate" this product by closing the loop between resume feedback and resume action.

My enhancement answers the user's next logical question: "My resume is good, but is it good for this job?" This makes the tool an active part of the job-seeking process rather than just a passive editor.

My Enhancements: From Editor to Career Co-Pilot

I enhanced the "Resume Editor" by adding a powerful job-matching and analysis engine. This transforms the tool from a simple editor into an "AI Career Co-Pilot."

AI-Powered Job Matching: The application analyzes the user's uploaded PDF resume against a database of real job postings.

Dynamic "Fit Score": Each job match is given a percentage score (e.g., "85% Fit"). This score is not based on simple keyword matching; it is generated by the Google Gemini API, which performs a deep semantic analysis of the resume against the job description.

Actionable Recommendations: This is the core enhancement. For each job match, the AI provides a list of specific, actionable recommendations (e.g., "Add the keyword 'Spring Boot' to your BEL internship description," or "Highlight your 'React Query' skill more prominently").

Full-Stack & Deployed: The entire application is built as a production-ready, full-stack solution, deployed on Vercel (Frontend) and Render (Backend + Database).

Modern UI/UX: Includes a responsive, mobile-first design with a light/dark mode toggle.

Tech Stack

Frontend: React (Vite), Tailwind CSS, Axios

Backend: Node.js, Express.js

Database: PostgreSQL

AI: Google Gemini API (gemini-2.5-flash)

PDF Parsing: pdf.js-dist (server-side)

Deployments:

Frontend: Vercel

Backend: Render (Web Service)

Database: Render (PostgreSQL)

Technical Challenges & Trade-offs

A significant technical challenge was the server-side parsing of PDF files in a modern Node.js (ESM) environment.

Initial attempts with pdf-parse and langchain led to deep dependency and module import conflicts (ERR_MODULE_NOT_FOUND, ERR_PACKAGE_PATH_NOT_EXPORTED).

Decision: After failing to resolve these import issues against the deadline, I made a trade-off to find a stable, modern library. I selected and successfully implemented pdf.js-dist (the library used by Mozilla) in a Node.js environment. This provided reliable text extraction and resolved all import errors, allowing for a production-ready submission.

Local Setup & Installation

1. Backend (/backend folder):

npm install

Create a .env file in the /backend root.

Add your environment variables:

DATABASE_URL="postgresql://YOUR_LOCAL_USER:YOUR_PASS@localhost:5432/your_db_name"
GEMINI_API_KEY="YOUR_GOOGLE_GEMINI_API_KEY"


Connect to your local PostgreSQL instance and run the database.sql file to create the tables.

Run node fetchJobs.js (after adding your RapidAPI key to the script) to create jobs.json.

Run node seedDb.js to populate your local database.

Run npm start to start the server.

2. Frontend (/frontend folder):

npm install

Create a .env.local file in the /frontend root.

Add your backend API URL:

VITE_API_URL="http://localhost:3001/api"


Run npm run dev to start the frontend.
